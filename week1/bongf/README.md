
작성 코드 : https://github.com/bong6981/toby-spring/commits/vol1-week1
# 1. 학습내용
-	여러 기능을 담당하던 UserDao에서 DB커넥션을 담당하는 ConnectionMaker를 분리했다.
-	ConnectionMaker를 인터페이스로 만들어 이를 구현하게 함으로써 DB커넥션을 변경이 용이하게 만들었다.
-	UserDao와 ConnectionMaker 인터페이스의 관계를 맺어줘서 (UserDao의 오브젝트와 ConnectionMaker 오브젝트의 관계) (클래스 사이의 관계가 아니다) 런타임 시점에(UserDaoTest) 구체 클래스를 결정할 수 있도록 했고 그에 따라 UserDao와 ConnectionMaker구체클래스와의 관계가 사라졌다. 
-	이를 통해 OCP를 지킬 수 있게 되었고 UserDao와 ConnectionMaker 각각이 높은 응집도를 가지면서 둘을 느슨하게 연결할 수 있었다(낮은 결합도)
	-	OCP지키기 : UserDao코드를 하나도 변경하지 않으면서도(변경에는 닫혀있다) UserDao는 여러 DB커넥션을 사용할수 있게 되었다.(더 정확하게는 ConnectionMaker 인터페이스를 사용하는 것이지만) 이는 UserDao의 확장
    -	높은 응집도 : 각각이 자기 관심사에만 관련된 기능만 담당
    -	느슨하게 연결 : 인터페이스를 통한 연결 
-	이 최종적인 UserDaoTest-UserDao-ConnectionMaker 의 구조는 전략 패턴에 해당한다
	-	UserDao : 컨텍스트
    -	UserDaoTest : 컨텍스트의 클라이언트 
    -	ConnectionMaker의 구체 클래스 : 컨텍스트가 사용할 전략

## 높은 응집도와 낮은 결합도
-	응집가 높다 : 하나의 모듈(클래스)가 하나의 책임&관심사에만 집중되어 있다
-	결합도가 낮다 : 책임&관심사가 다른 오브젝트들 간, 다른 모듈 간은 느슨하게 연결되어 있다

## 전략패턴
-	Context에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 외부로 분리시키고 이를 구현한 구체 클래스를 필요에 따라 바꿔 사용할 수 있게 하는 디자인 패턴
-	대체가능한 전략이다 : 전략패턴
-	컨텍스트의 클라이언트가 컨텍스트가 사용할 전략을 컨텍스트에게 제공해주는 것이 일반적


# 2. 기타 코드를 작성하며 배울 수 있던

## 팩토리메서드 패턴과 템플릿 메소드 패턴
-	UserDao에서 기능을 DB connect 기능을 분리할 때 처음에드 UserDao를 추상클래스로 만들고 이를 하위클래스 구현하게 해서 이 구현과정에서 DB connect를 하게 하는 방식으로(상속) 분리했다.
-	이렇게 분리했을 때 팩토리메서드 패턴과 템플릿 메소드 패턴을 적용한 것이라 할 수 있다
-	책 내용만 보고는 의미가 와닿지 않아 이 [블로그](https://western-sky.tistory.com/40#:~:text=%ED%8C%A9%ED%86%A0%EB%A6%AC%20%EB%A9%94%EC%84%9C%EB%93%9C%20%ED%8C%A8%ED%84%B4%EC%9D%98%20%EA%B2%BD%EC%9A%B0,%EB%A5%BC%20%EB%B3%80%EA%B2%BD%ED%95%A0%20%ED%95%84%EC%9A%94%EA%B0%80%20%EC%97%86%EC%97%88%EC%A3%A0.&text=%ED%85%9C%ED%94%8C%EB%A6%BF%20%EB%A9%94%EC%84%9C%EB%93%9C%20%ED%8C%A8%ED%84%B4%EC%9D%98%20%EA%B2%BD%EC%9A%B0%20%EC%9E%AC%EC%82%AC%EC%9A%A9%EC%84%B1%EC%9D%B4%20%ED%81%AC%EA%B2%8C%20%EC%A6%9D%EA%B0%80%ED%96%88%EC%8A%B5%EB%8B%88%EB%8B%A4)를 참고 했다.
-	나는 팩토리 메서드 패턴은 상위 클래스에서 하위 클래스에서 어떻게 구현할지 신경쓰지 않고도 반환하는 객체를 사용할 수 있다는 것에 포커스를 두고 이해했다. (객체생성하는 클래스를 하위 클래스로 분리하는 것에 포커스)  
	-	팩토리 공장이(하위 클래스)에서 어떻게 생산하든 그 생산한 (토비 스프링 책에서는 Connection)을 사용할 수 있는 것에 포커스
    -	하위클래스에서 사용하도록 팩토리 메소드를 둔다
-	템플릿 메소드 패턴은 (위의 블로그에 따라) 전반적인 로직은 유지 하면서 하위 클래스에서 세부사항을 변경할 수 있도록(**확장**을 열어둔) 것에 포커스를 맞춘 것으로 이해했다. 
	-	템플릿 메소드, 훅 메소드, 추상 메소드로 나눈다. 템플릿 메소드로 공통적인 로직을 잡고 추상메소드는 하위 클래스에서 반드시 구현해야 하고 훅 메소드는 선택적으로 구현하거나 수정할 수 있게 해둔다

## 상속의 문제점
-	자바는 단일 상속만 지원(다중상속 지원x)하기 때문에 다른 것들을 상속받기가 어렵다는 문제
-	상속으로 연결된 클래스는 매우 강한 결합이다. 슈퍼클래스의 기능을 하위클래스에서 그대로 사용하기 때문에 슈퍼클래스에서의 변화는 해당 변화에 속하는 기능을 사용하는 하위클래스의 코드까지 변화를 초래
-	디비에 데이터를 넣고,조회하는 로직과 DB커넥션을 담당하는 로직이 강하게 결합될 필요가 있을까?
-	이렇게 관련 없는 두 코드를 강하게 묶어줬기 때문에 다른 곳에서 이 디비커넥션을 담당하는 부분을 재사용할 수 없다(코드 중복 우려) 

## JDBC를 이용하는 작업의 일반적인 순서
![](https://images.velog.io/images/bongf/post/ae7f09ad-e2ad-4e72-8299-2f9eb6b4dd18/image.png)
![](https://images.velog.io/images/bongf/post/a992d357-fd6a-40ec-805c-df096a45cfd8/image.png)
-	1. DB 연결을 위한 Connection을 가져온다
-	2. SQL을 담은 Statement(또는 PreparedStatement)를 만든다
-	3. 만들어진 Statement를 실행한다
-	4. 조회의 경우 SQL 쿼리의 실행 결과를 ResultSet으로 받아서 정보를 저장할 오브젝트(여기서는 User)에 옮긴다
-	5. 작업중에 생성된 Connection, Statement, ResultSet 같은 리소스는 작업을 마친 후 반드시 닫아준다
-	6. JDBC API가 만들어내는 예외를 잡아서 직접 처리하거나, 메소드에 throws를 선언해서 예외가 발생하면 메소드 밖으로 던지게 한다

# 3. 물어볼 사항
- 로빈과 트리도 mysql 한글 설정할 때 코쿼에서 알려준 mysql.conf.d? 말고 my.cnf 파일에 같은 내용 작성해야 바뀌는지?
